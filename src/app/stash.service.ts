import { Injectable } from '@angular/core';
import { Observable } from 'rxjs/Observable';

import 'rxjs/add/operator/catch';
import 'rxjs/add/operator/map';
import 'rxjs/add/observable/throw'; // needed for the 'throw' operator to work

import { Stash } from './classes/stash';
import { ANGULAR2 } from './data/mockStash';
import { AppResponse } from './classes/response';
import { Http, Response, Headers, RequestOptions } from '@angular/http';
import { SERVER } from './classes/SERVER';
import { AccountService } from './account.service';
import { Account } from './classes/account';
import { Deferred } from './classes/deferred';

@Injectable()
export class StashService {

  constructor(private http: Http, private accountService: AccountService) {

  }

  /**
   * Create a stash based on the given parameters
   * the id will be generated by hashing the title
   * 
   * @param stash - the details of the stash (including title and description)
   */
  createStash(stash: Stash): Observable<AppResponse> {
    let options: RequestOptions;
    this.setupHeaderOptions(options);

    // Update the author_id of the stash to be created
    let userID: string = this.accountService.getCurrentUserID();
    let updatedStash = stash;
    updatedStash.author_id = userID;

    return this.http.post(
      SERVER + '/stash/new',
      {
        stash: updatedStash
      },
      options
    ).map(response => {
      console.log(response);
      return new AppResponse(true, 'Stash created successfully.');
    }).catch(error => {
      console.log(error);
      return Observable.throw(error);
    });
  }

  /**
   * Update a stash based on the given stash object
   * 
   * @param stash - the stash to be updated. Should already by populated 
   *                with new content
   */
  updateStash(stash: Stash): Promise<AppResponse> {
    let deferred = new Deferred<AppResponse>();

    if (stash.author_id == null || stash.stash_id == null ||
      stash.description == null || stash.title == null
    ) {
      deferred.reject('Missing parameters from the stash.');
    } else {
      let options: RequestOptions;
      this.setupHeaderOptions(options);

      this.http.post(
        SERVER + '/stash/update',
        {
          stash: stash
        }
      ).subscribe(response => {
        deferred.resolve(new AppResponse(true, response.toString()));
      }, error => {
        deferred.reject(new AppResponse(false, error, error));
      });
    }

    return deferred.promise;
  }

  /**
   * Delete a stash. The stashID must be present stash for it to be deleted.
   * 
   * @param stash - The stash to be deleted
   */
  deleteStash(stash: Stash): Observable<AppResponse> {
    if (stash.stash_id == null) {
      return Observable.throw('StashID must be present.');
    }

    let options: RequestOptions;
    this.setupHeaderOptions(options);

    return this.http.post(
      SERVER + '/stash/delete',
      {
        stash: stash
      }
    ).map(
      response => {
        return new AppResponse(true, 'Stash successfully deleted.');
      }
      ).catch(
      error => {
        return Observable.throw(error);
      }
      )
  }

  /**
   * 
   * @param title  the title of the stash
   */
  getStashInformation(title: string): Promise<Stash> {
    return Promise.resolve(ANGULAR2[0]);
  }

  /**
   * Retrieve all the stashes for a given user
   * 
   * @param userEmail - The email of the user whose stashes are to be retrieved
   */
  getAllStashes(): Observable<Stash[]> {
    let user: Account = this.accountService.getCurrentUser();

    let options: RequestOptions;
    this.setupHeaderOptions(options);

    return this.http.get(
      SERVER + '/stashes/all/' + user.email,
      options
    ).map(response => {
      // Attempt to convert the response to the array of stashes
      let stashes: Stash[] = response.json();

      return stashes;
    }).catch(error => {
      console.log(error);
      return Observable.throw(error);
    });
  }

  /**
   * Get all stashes that this user is a collaborator of
   */
  getAllSharedStashes(): Promise<Stash[]> {
    let deferred = new Deferred<Stash[]>();

    let options: RequestOptions;
    this.setupHeaderOptions(options);

    let user: Account = this.accountService.getCurrentUser();

    // Now retrieve the user id from the server
    this.accountService.getUserID(user.email).then(user_id => {
      this.http.post(
        SERVER + '/stashes/shared/all',
        {
          user_id: user_id
        },
        options
      ).subscribe(response => {
        // Cast the response to a stash
        let stashes = response.json();
        deferred.resolve(stashes);
      }, error => {
        deferred.reject(error);
      })
    })

    return deferred.promise;
  }

  /**
   * Get the information of a specific stash.
   * 
   * @param stashID - The id of the stash to be retrieved
   */
  getStash(stashID: string): Promise<Stash> {
    let deferred = new Deferred<Stash>();

    let options: RequestOptions;
    this.setupHeaderOptions(options);

    this.http.get(
      SERVER + '/stash/' + stashID,
      options
    ).subscribe(response => {
      // Cast the response to a stash
      let stash = response.json();
      deferred.resolve(stash);
    }, error => {
      deferred.reject(error);
    })

    return deferred.promise;
  }

  /**
   * HELPER METHODS
   */
  setupHeaderOptions(options: RequestOptions) {
    let headers = new Headers({
      'Content-Type': 'application/json'
    });
    options = new RequestOptions({ headers: headers });
  }
}
